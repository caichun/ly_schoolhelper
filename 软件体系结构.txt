-软件架构概念 
-模型与建模方法 （4+1视图模型）
-风格与模式
-基于架构的软件开发
-架构演化与维护
 
软件架构
定义：软件架构-元素，组成，原理
软件架构包括构件（component），连接件，约束（基本元素）端口和角色
		构建和交互关系的集合（组成派）、重要设计决策的集合（决策派）
软件系统设计图，包含软件设计决策（结构组织）
特征：重用性、利益相关者多、关注点分离（模块化，分治）、质量驱动（非功能性需求）、概念完整性、循环风格
发展阶段：
1、基础研究阶段：Modular（模块化，逻辑切分）
2、概念体系核心技术形成：Software architecture，component（组件化，功能分隔）
3、理论体系丰富：基于组件软件架构
架构描述：ADL、形式化方法、4+1架构、UML、IEEE软件架构描述
	架构分析：结构分析（开发风格选择），功能分析，非功能分析
	设计方法：artifact（工作），use case（用例），pattern（模式），domain（领域），Attribute（属性）-Driven design驱动
	测试：仿真系统测试
软件架构风格：数据流、调用返回、独立组件（进程通信）、虚拟机（解释器）、仓库
架构模型
	对架构设计决策具象化和文档化
	建模方法：非规范图形（盒线图），UML（半形式化语言，机器不易处理），形式化建模（符号化，机器可处理，难以阅读），基于UML形式化
	UML：定义了丰富模型元素及建模组件（分类器：类，组件，节点，用例），接口，关系（泛化，关联，依赖，继承）和约束（规则）
	UML：表示法统一，支持多视图，建模能力不强，语义精确性不足，软件架构风格无法体现 建模阶段：当作架构语言直接建模，扩展机制约束丰富元模型，扩充元模型
	形式化建模：Z语言，Petri网，B语言，CSP（新语言，难学难用）
	UML形式化：用符号语言对UML进行规约 需求分析-规格说明-UML建模-形式化描述-编码-形式规范自动生成测试变量-产品 故障越早发现，修复成本越低
		类：名称，属性，操作	关联（Association）：名字，两关联端
	文本语言建模：文档描述整体架构，无图形结构不易理解	语法高亮，静态检查，自动补全，代码折叠
	Model Driven Architecture（模型驱动架构建模）：Platform Independent（PIM平台无关），Specific（PSM平台相关）Model	构造平台无关模型（PIM）验证可行并移植至平台相关模型（PSM）

风格与模式（style & pattern）
	架构风格：描述特定领域中系统组织方式的惯用模式
		设计元素（管道，过滤器，对象，服务），配置规则，语义解释
		设计代码重用性，组织结构易理解，内部互操作性，需求和风格分析
		
	风格分类：数据流（1）、调用返回 主-子程序（2）、独立组件（3，4）（进程通信）、虚拟机（解释器）、仓库
		解释器：逐条边翻译边执行（程序可移植，语言跨平台 效率低JVM）	
		编译器：编译为二进制文件，保存并执行
		Java：编译（编译产生.class文件+解释）
		1.	管道过滤器：输入-管道-过滤器(功能模块)-管道-输出（支持功能模块复用和替换，可维护和扩展性高，吞吐量的计算，死锁问题，过滤器相对独立性，高内聚低耦合，过滤器可同步开发 交互能力弱，数据可能泄露 例：编译器）
		2.	主，子程序风格：逐步分解细化，调用返回（数据访问效率高，不同模块包含不同功能，可复用性低，高善入模块稳定性要求高，程序宽度(模块复杂)，深度(数据传递次数多）高善入：被多个模块调用）
		3.	面向对象：对象维护自身完整性，对象之间相互隐蔽，类标识调用独立性低
		4.	层次化：系统组织为若干层次，层间存在接口，通过接口形成服务（问题分解，支持扩展，重用	OS）
		5.	事件驱动：监听广播事件触发过程（独立，可复用性强	监听响应组件无控制权，无数据交换，正确性验证困难 win32GUI）
		6.	解释器风格（Interpreter）：逐条边翻译边执行（程序可移植，语言跨平台，效率低JVM）
		7.	基于规则的系统：提取频繁变化的业务逻辑形成规则库，运行时读取规则（跨场景）
		8.	仓库风格：两种组件：中央数据存储组件，相对独立组件（可扩展性好 需有同步机制防止数据死锁）
		9.	黑板系统：知识源-控制器-黑板（数据结构）-控制器-知识源（知识源之间相互独立，仅与黑板交互）（知识共享，黑板数据结构可扩展重用 对黑板数据结构要求高，需同步和加锁机制）		
		10.	C2风格：通过连接件绑定在一起的组件网，通信和处理分开（分层结构，易重用和替换，不需共享地址空间，多用户	大规模流式风格时不适用）
		11.	客户机/服务器：两层CS（客户机（Fat client）：业务逻辑，通信	服务器：通信，业务逻辑，数据管理（组件相互透明，扩展灵活性	开发成本高，客户机复杂度大，信息内容单一，难以升级，数据安全性低））	三层CS：数据库外围架设应用服务器（业务逻辑层）进行访问筛选(客户端与服务器均实现瘦身，将控制逻辑置于业务逻辑层）（数据安全，逻辑清晰，可维护性好，不同模块间可并行开发）
		12.	浏览器/服务器：BS风格是对三层CS风格的改进方式之一，通过浏览器通过访问web服务器实现对web，数据服务器访问（客户端占用资源少，操作简单，开发成本低		个性化程度低，交互性不强，服务器负担重，可扩展性差安全性低，数据库查询速度低）
		13.	平台/插件：plug-in插件（遵循统一预定义接口实现，应用程序在运行时根据接口归约进行调用，对软件功能进行加强）platform平台（内核+插件处理（平台扩展接口））（降低模块依赖性，模块独立开发与维护，动态组装/分离	可重用性差）
		14.	面向Agent风格： Agent组件/连接件 具有自主，智能，交互等特性，根据所处环境智能进行行为		
		15.	面向方面Aspect：系统中一些需求横切于系统，考虑横向关注点（方面）形成组件与连接件（定义交叉关系，层次化，面向对象）
		16.	面向服务：注重对用户提供的服务，应用不同功能单元通过良好的接口和契约联系，service：粗粒度、可发现的软件实体 实现平台无关 服务提供者-注册中心(UDDI)-服务请求者	（标准化架构易于集成和共享，系统松散耦合降低开发成本与维护复杂度）
		17.	正交架构：层（Layer），线索（Thread），组件（Component） 通过组件通过线索调用不同层的组件（正交），线索间互不相关（完全正交）
		18.	异构风格：多种架构通过层次组合，允许单一组件有复合连接件（遗留代码重用，解决解释习惯上差异	不同风格兼容问题解决困难BS-CS内外/查改有别）
		19.	层次消息总线：构件（单一/复合）通过网络与消息总线连接（构件耦合，灵活性高，支持动态演化 重用要求高）
		20.	MVC：视图（用户界面）-控制器（控制交互）-模型（核心数据，算法），主要应用于用户交互程序设计（良好的移植性，便于维护	增加复杂性，系统效率低）
	架构模式：根据系统的结构组织定义系统族以及组件件关系
	领域，平台相关性强，反应最佳解决方案

架构描述语言
	ADL：任何用于软件架构的表示形式（Aesop架构风格，MetaH电子控制，C2，Rapide模型）
		C2：用户界面密集系统，按照特定形式描述架构，方便机器读取

架构与敏捷开发
	软件开发：松散开发->软件工程思想->敏捷开发->智能化开发
	敏捷开发(宣言)：需求，设计，编码，测试（可运行软件，客户合作，响应变化 迭代增量，持续集成）
1.	尽早交付可用软件
2.	欢迎变化为客户赢得优势
3.	经常交付
4.	业务与开发人员共同工作，紧密开发
5.	支持并信任项目开发人员
6.	长期稳定的开发速度
7.	关注技术和设计
8.	KIS（Keep It Simple)
	敏捷架构设计：种子（开发前设计，可扩展性，骨架与轮廓），详细架构设计（分解架构设计过程，尽早集成，降低开发风险）
	初始设计：全局抽象层次设计，达成关于项目周期目标协议，确定业务和需求风险
	迭代过程：迭代设计（根据工作任务进行需求分析，设计，编码），重构（梳理架构，进行持续改进），确定架构（测试软件），客户交流（交流反馈，完成新需求），应对需求不可预测性，长期计划不稳定，单次迭代短期计划是稳定的
	XP：简单设计（发布计划，分配任务），结对编程（根据任务编码）,测试驱动开发（debugs），发布（确认需求与反馈，文档化）
		Scrum：计划会议（Sprint backlog）->每日例会->燃尽图（预期进度与实际进度）->回顾会议（发布）
		FDD：开发设计，设计包（并发独立开发），完成（根据特征构造）
架构驱动软件开发：需求获取，架构设计，文档化，架构评估，实现，维护
		架构需求：
			需求来源：系统质量，业务，软件利益相关者（讨论架构层次需求，不需直接深入功能性需求）
			需求获取：用户群，环境与架构经验->需求获取->特定质量场景（提取抽象场景，性能，可移植，替换，重用性）
			质量模型描述：对质量场景进行描述，评估与预测质量属性（软件质量元模型：软件质量理想设计原则，描述元素之间关系）
		基本架构设计：功能->架构需求列表，开发子系统，发布架构设计（从0开始软件开发）
		架构文档化：利益相关者间联系，制定满足需求架构
		架构结构：对架构的描述，系统可靠，可用，安全性分析（基于功能（功能需求分解 组件/连接件），代码（软件设计中关键性代码抽象描述 组件：包，类…），并发（线程与进程控制描述），物理（中央处理器，存储器，网络与IO设备描述 系统可用性与性能），开发（文件目录与团队分工））
		架构评估：分析架构识别架构风险，验证已满足质量需求
		实现与维护：架构与开发团队组织结构一致性，文档维护

架构设计与实现
	架构品质：模块化，适应需求/技术变化，系统动态运行与数据规划，明确灵活的部署规划
	需求分析到架构设计：包含架构概念的需求规约，系统架构高层表述
		1.	确定问题空间
		2.	确定用户职责
		3.	用户角度探索系统行为，形成系统模型
		4.	确定，规约组件连接件
	难点：描述语言转换，非功能需求难以规约，一致性难复杂度高，需求庞大
	面向目标与场景的架构设计：需求模型，use-case图，部件划分，逐步求精权衡
	需求与架构相互影响形成螺旋式开发
	详细设计：架构表达式细化，数据结构与算法选择（语言相关 接近源码的软件表示）
	Model Driven Architecture模型驱动架构：计算无关模型（CIM业务模型，描述系统外部行为），平台无关模型（PIM高抽象，实现技术无关），平台特定模型（确定实现技术）
	设计原则：一般（数据，应用程序，技术），关键原则（关注点分离，单一职责，松耦合，功能分离）
	架构设计威胁：
		1.	忽略非功能需求（全面认识需求）
		2.	频繁变化需求（关键需求决定架构）
		3.	非全面架构设计
		4.	不及时架构验证（尽早进行架构验证）
		5.	创造性架构比重（加强经验架构使用）
		6.	架构低可执行性（验证架构可执行性,避免过度设计）
	示例：
	项目背景，需求分析（功能（use-case细化）/非功能（质量场景）），架构设计（整体架构）
		非功能需求：性能场景（响应度量，容量 AVG≤5s，同时500个用户），安全性（杜绝非法访问，隔离无意义访问），易用性，可用性
		结构设计：SSH多层架构模式 视图-控制-模型-数据库层
	票务系统：非功能需求（性能（响应度量，容量 AVG≤5s，同时500个用户），安全性（杜绝非法访问，隔离无意义访问），易用性，可用性），功能需求（使用use-case图进行细化分析），结构设计（SSH多层架构模式 视图-控制-模型-数据库层）

体系结构评估：
	了解体系结构的属性，屏蔽风险
	质量属性：可修改（功能，容量扩展），可用（可正常运行时间占比），可测试（缺陷易被查出），易用（用户体验与效率），安全性（对非法操作防范），性能（响应速度）
	评估作用：降低开销，挖掘隐性需求
	评估方式：调查问卷（评估灵活自由 主观性强），基于场景（相对主观 领域依赖性高，需丰富领域知识），基于度量（通过度量值判断架构质量 较为客观，对体系具体情况精确了解）
	体系结构权衡分析ATAM：体系结构权衡分析（敏感点：构件特征（质量目标注意点），权衡点：多个质量属性的敏感点）（基于场景）
		场景描述：刺激，环境，响应
		评估步骤：ATAM方法陈述，业务动机，体系结构，体系结构方法，效用树（系统整体质量（效用-质量属性-属性求精-场景（优先级	场景重要性，实现难度））），分析体系结构，集体讨论确定优先级，陈述结果
	Software Architecture Analysis Method：分析体系结构可修改性，系统属性与功能
		评估步骤：场景形成（集体讨论），体系结构描述（静态/动态特征），场景分类优先级划分（直接场景（体系结构满足新需求）/间接场景（新需求实现需更改体系结构）），单个场景评估（间接场景评估，提出修改），场景交互评估（分析场景间关系），总体评估
		Tips：CASL（场景：文本格式支持，增加索引显示风格（文本编辑模块），格式长度，系统平台移植（代码生成模块等，调用系统API所有模块）。。。）统计模块更改需求，并分析其间关系

架构演化与维护：
	架构生命周期：初始设计，实际使用，修改完善，弃用
	架构演化：维持架构自身有用性（组件，连接件，约束的增删改）
		顺序图：组件（对象的增删），连接件（消息增删交换与角色反转，复合片段增删与类型修改），约束（文字描述添加删除）
	静态演化：设计时与运行前，软件架构设计，实现，维护
		一般过程：软件理解（提取系统抽象表示），需求变更分析，演化计划（分析原系统，选择演化计划），系统重构，系统测试
	动态演化：软件内部执行或外部请求导致的结构改变与重配置
		演化类型：交互，结构，架构动态性
		动态软件架构（DSA运行时时刻捕捉并分析需求变化），动态重配置（根据任务来源与优先级实现动态分配）
	演化原则：成本控制，



	



